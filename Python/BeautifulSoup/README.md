## Beautiful Soup 4
Python library for pulling data out of HTML and XML

### Quick Start
```python
html_doc = open('example.html', 'r').read()

#html_doc = html string or a file handler
#'html.parser' = name of parser
soup = BeautifulSoup(html_doc, 'html.parser')

#indentationed soup
print(soup.prettify())
```

### Methods

find_all()
find()
get()
get_attribute_list()


### Basic Navigation
BeautifulSoup transforms a complex HTML document into a complex tree of Python objects.

```python
soup.title
# <title>TheDormouse's story</title

soup.title.name
# u'title'

soup.title.parent.name
# u'head'

soup.p
# <p class="title"><b>The Dormouse's story</b></p>

soup.p['class']
# u'title'

soup.a
# <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>

soup.find_all('a')
# [<a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,
#  <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>,
#  <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]

soup.find(id="link3")
# <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>


```
##### Extract URL from in all <a> tags

```python
for link in soup.find_all('a'):
    print(link.get('href'))
# http://example.com/elsie
# http://example.com/lacie
# http://example.com/tillie
```

##### Extracting all text from a page

```python
print(soup.get_text())
```

### Kind of objects

#### Tag
Corresponds to an XML or HTML tag in the original document:

```python
soup = BeautifulSoup('<b class="boldest">Extremely bold</b>', 'html.parser')
tag = soup.b
type(tag)
# <class 'bs4.element.Tag'>
```

###### Name
Every tag has a name, accessible as .name:

```python
print(tag.name)
# 'b'
```

If the tag's name is changed it will be reflected in any HTML markup generated by Beautiful Soup

```python
tag.name = 'blockquote'
print(tag)
# <blockquote class="boldest">Extremely bold</blockquote>
```

##### Attributes
The tags attributes can be added, removed and modified, this is done by treating the tag as a dictionarie. All the information is stored in .attrs attribute

```python
tag = BeautifulSoup('<b id="boldest">bold</>', 'html.parser').b
tag['id']
# boldest

tag.attrs
# {'id': 'boldest'}

tag['id'] = 'verybold'
tag['another-attribute'] = 1
tag
# <b another-attribute="1" id="verybold"></b>

del tag['id']
del tag['another-attribute']
tag

# <b>bold</b>

tag['id']
# KeyError: 'id'
tag.get('id')
# None
```

###### Multi-valued attributes

There's a couple of attributes that support multiple values, the most common is the 'class' 
attribute. When this values are requested from the BeautifulSoup it returns a list of strings.

```python
css_soup = BeautifulSoup('<p class="body"></p>', 'html.parser')
css_soup.p['class']
# ['body']

css_soup = BeautifulSoup('<p class="body strikeout"></p>', 'html.parser')
css_soup.p['class']
# ['body', 'strikeout']
```
If an attribute looks like it has more than one value, but it's not a multi-valued attribute as defined by any version of the HTML standard, Beautiful Soup will leave the attribute alone.

```python
rel_soup = BeautifulSoup('<p>Back to the <a rel="index">homepage</a></p>', 'html.parser')
rel_soup.a['rel']
# ['index']

rel_soup.a['rel'] = ['index', 'contents']
print(rel_soup.p)
# <p>Back to the <a rel="index contents">homepage</a></p>

rel_soup.a['id'] = ['the', 'one', 'id']
rel_soup.a
# <a id="the one id" rel="index">homepage</a>

rel_soup.a.get('id')
# ['the', 'one', 'id']

```

This can be disable by passing multi_valued_attributes=None as a keyword argument into the BeautifulSoup constructor

```python
no_list_soup = BeautifulSoup('<p class="body strikeout"></p>', 'html.parser', multi_valued_attributes=None)
no_list_soup.p['class']
# 'body strikeout'
```
Function get_attribute_list can be used to ensure that it always return a list with a single element if the multi_valued_attributes is set to None.\

It is possible to configure the multi_valued_attributes argument with a dictionary

```python
class_is_multi= { '*' : 'class'}
xml_soup = BeautifulSoup('<p class="body strikeout"></p>', 'xml', multi_valued_attributes=class_is_multi)
xml_soup.p['class']
# ['body', 'strikeout']
```
### NavigableString

A NavigableString is just lika a Python Unicode string, except that it also supports some other features.

```python
soup = BeautifulSoup('<b class="boldest">Extremely bold</b>', 'html.parser')
tag = soup.b
tag.string
# 'Extremely bold'
type(tag.string)
# <class 'bs4.element.NavigableString'>

unicode_string = str(tag.string)
unicode_string
# 'Extremely bold'
type(unicode_string)
# <type 'str'>
```

Its not recomended to edit the string attribute because it will replace it with a string class.
Strings don't support the .contents or .string attributes, or the find() method.
To replace one string with another use replace_with();

### BeautifulSoup

The BeautifulSoup object represents the parsed document as a whole, it can be treated as Tag object with some restrictions.


```python
doc = BeautifulSoup("<document><content/>INSERT FOOTER HERE</document", "html.parser")
footer = BeautifulSoup("<footer>Here's the footer</footer>", "html.parser")
doc.find(text="INSERT FOOTER HERE").replace_with(footer)
# 'INSERT FOOTER HERE'
print(doc)
# <document><content/><footer>Here's the footer</footer></document>
```

This object do not correspond to an actual HTML or XML tag. It has no name and no attributes.
Only has .name attribute.

### Navigating

A Tag object is composed by Tags and NavigatableStrings. A children Tag can be acessed with the attribute name of the tag.
The .contents method returns a list of Tags and NavigableStrings inside the object that called the function.
The .children method returns a iteratable list of Tags and NavigableStrings
The .descendants method is a recursive iteratable of Tags and NavigableStrings

```python
soup = BeautifulSoup('<html><head><title>Just a Test</title></head><body><p>Example</p><p>Another example</p></body></html>', 'html.parser')
body = soup.body

body
# <body><p>Example</p><p>Another example</p></body>

body.contents
# [<p>Example</p>, <p>Another example</p>]

for child in soup.body.children:
	print(child)
	print(child.__class__)

# <p>Example</p>
# <class 'bs4.element.Tag'>

# <p>Another example</p>
# <class 'bs4.element.Tag'>


len(list(body.contents))
# 2
len(list(body.descendants))
# 4
```

If there's more than a string insede of a Tag element, its possible to only ask fro the strings.

```python
for string in body.strings
```
